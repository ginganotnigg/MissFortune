{"context": "Design patterns are typical solutions to common problems in software design. Each pattern is like a blueprint that you can customize to solve a particular design problem in your code.", "question": "True or False: Design patterns are unique solutions that can only be applied to one specific problem.", "answer": "FALSE. Design patterns are typical solutions to common problems that can be customized for different design problems.", "type": "True/False"}
{"context": "The Observer pattern defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.", "question": "True or False: In the Observer pattern, when the observed object changes state, all its dependents are notified and updated automatically.", "answer": "TRUE. The Observer pattern defines a one-to-many dependency where dependents are notified when the observed object changes state.", "type": "True/False"}
{"context": "The Single Responsibility Principle (SRP) states that a class should have only one reason to change, meaning it should have only one responsibility.", "question": "True or False: According to the Single Responsibility Principle, a class should handle multiple responsibilities to be more efficient.", "answer": "FALSE. The Single Responsibility Principle states that a class should have only one responsibility, not multiple ones.", "type": "True/False"}
{"context": "The Factory Method Pattern defines an interface for creating an object, but lets subclasses decide which class to instantiate. It allows a class to defer instantiation to subclasses.", "question": "True or False: The Factory Method Pattern allows the parent class to control which subclasses are instantiated.", "answer": "FALSE. The Factory Method Pattern lets subclasses decide which class to instantiate, not the parent class.", "type": "True/False"}
{"context": "The Open/Closed Principle states that software entities should be open for extension but closed for modification. This means you should be able to add new functionality without changing existing code.", "question": "True or False: According to the Open/Closed Principle, you should be able to add new functionality without changing existing code.", "answer": "TRUE. The Open/Closed Principle specifically states that software entities should be open for extension but closed for modification.", "type": "True/False"}
{"context": "Neural networks consist of artificial neurons organized in layers, capable of learning patterns from data. The input layer receives data, hidden layers process it, and the output layer produces results.", "question": "True or False: In neural networks, the output layer receives the initial data and the input layer produces the final results.", "answer": "FALSE. In neural networks, the input layer receives the initial data, hidden layers process it, and the output layer produces the final results.", "type": "True/False"}
{"context": "Supervised Learning is where models learn from labeled training data to predict outputs for unseen data. Key components include features, labels, and a loss function to measure prediction errors.", "question": "True or False: In supervised learning, models learn from unlabeled data.", "answer": "FALSE. Supervised learning uses labeled training data, not unlabeled data.", "type": "True/False"}
{"context": "RESTful APIs use HTTP requests to perform CRUD (Create, Read, Update, Delete) operations. They are stateless, meaning each request from client to server must contain all information needed to understand and process the request.", "question": "True or False: RESTful APIs maintain state information between requests from the client to the server.", "answer": "FALSE. RESTful APIs are stateless, meaning each request must contain all information needed to process it without relying on previous requests.", "type": "True/False"}
{"context": "A hash table is a data structure that implements an associative array abstract data type, a structure that can map keys to values. A hash table uses a hash function to compute an index into an array of buckets or slots.", "question": "True or False: A hash table uses a sequential search to find values in the data structure.", "answer": "FALSE. A hash table uses a hash function to compute an index, not a sequential search.", "type": "True/False"}
{"context": "Test-Driven Development (TDD) is a software development process relying on a very short development cycle: first, the developer writes a failing automated test case for a new feature, then produces the minimum amount of code to pass that test, and finally refactors the code to meet acceptable standards.", "question": "True or False: In Test-Driven Development, developers write code first and then create tests to verify it works correctly.", "answer": "FALSE. In TDD, developers first write a failing test case, then write the minimum code to pass that test, and finally refactor.", "type": "True/False"}
{"context": "The Model-View-Controller (MVC) is an architectural pattern that separates an application into three main logical components: the model, the view, and the controller.", "question": "True or False: The MVC pattern combines all application logic into a single component for efficiency.", "answer": "FALSE. The MVC pattern separates an application into three distinct components (model, view, and controller), not a single component.", "type": "True/False"}
{"context": "A depth-first search (DFS) is an algorithm for traversing or searching tree or graph data structures. It starts at the root and explores as far as possible along each branch before backtracking.", "question": "True or False: A depth-first search explores all nodes at the same depth before moving deeper into the tree.", "answer": "FALSE. A depth-first search explores as far as possible along each branch before backtracking, unlike breadth-first search which explores all nodes at the same depth first.", "type": "True/False"}
{"context": "Agile methodology is an approach to software development that emphasizes incremental delivery, team collaboration, continual planning, and continual learning. It focuses on delivering value early and often.", "question": "True or False: Agile methodology emphasizes detailed upfront planning and documentation before any implementation begins.", "answer": "FALSE. Agile methodology emphasizes incremental delivery, collaboration, and continual planning rather than extensive upfront planning.", "type": "True/False"}
{"context": "Dependency Injection is a design pattern in which an object receives other objects that it depends on. These other objects are called dependencies.", "question": "True or False: In Dependency Injection, an object creates its own dependencies internally.", "answer": "FALSE. In Dependency Injection, an object receives its dependencies from external sources rather than creating them internally.", "type": "True/False"}
{"context": "Microservices architecture is an approach to developing an application as a collection of small services, each running in its own process and communicating with lightweight mechanisms. Each service is built around business capabilities and can be deployed independently.", "question": "True or False: In a microservices architecture, services must be deployed together as a single unit.", "answer": "FALSE. In microservices architecture, each service can be deployed independently, not as a single unit.", "type": "True/False"}
{"context": "Containerization, like Docker, packages an application with its dependencies, libraries, and other binaries, and with configurations needed to run it. This eliminates the 'it works on my machine' problem.", "question": "True or False: Containerization helps eliminate the 'it works on my machine' problem by packaging an application with its dependencies and configuration.", "answer": "TRUE. Containerization specifically addresses the 'it works on my machine' problem by packaging everything needed to run the application consistently across different environments.", "type": "True/False"}
{"context": "Big O notation is used to classify algorithms according to how their run time or space requirements grow as the input size grows. It provides an upper bound on the growth rate of the algorithm.", "question": "True or False: Big O notation describes the exact run time of an algorithm rather than its growth rate.", "answer": "FALSE. Big O notation describes how an algorithm's run time or space requirements grow as input size increases, providing an upper bound on growth rate, not the exact run time.", "type": "True/False"}
{"context": "The Liskov Substitution Principle states that objects of a superclass should be replaceable with objects of a subclass without affecting the correctness of the program. This is a fundamental principle of object-oriented design.", "question": "True or False: According to the Liskov Substitution Principle, a subclass should be able to replace its superclass without affecting program correctness.", "answer": "TRUE. The Liskov Substitution Principle states that objects of a superclass should be replaceable with objects of a subclass without affecting the correctness of the program.", "type": "True/False"}
{"context": "SQL injection is a code injection technique used to attack data-driven applications. It exploits security vulnerabilities in an application's software by inserting malicious SQL statements into entry fields.", "question": "True or False: SQL injection attacks work by overloading a server with multiple requests to cause it to crash.", "answer": "FALSE. SQL injection attacks work by inserting malicious SQL statements into entry fields to exploit vulnerabilities, not by overloading servers with requests (which would be a denial of service attack).", "type": "True/False"}
{"context": "A binary search tree is a tree data structure in which each node has at most two children, referred to as the left child and the right child. For each node, all elements in the left subtree are less than the node, and all elements in the right subtree are greater.", "question": "True or False: In a binary search tree, elements in the right subtree can be less than the node value.", "answer": "FALSE. In a binary search tree, all elements in the left subtree must be less than the node, and all elements in the right subtree must be greater than the node.", "type": "True/False"}