{"context": "Design patterns are typical solutions to common problems in software design. Each pattern is like a blueprint that you can customize to solve a particular design problem in your code.", "question": "What is the primary purpose of design patterns in software engineering?", "answer": "To provide typical solutions to common problems in software design", "type": "Multiple Choice", "options": ["To provide typical solutions to common problems in software design", "To create visual representations of code structure", "To replace object-oriented programming entirely", "To optimize database queries"]}
{"context": "The Observer pattern defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.", "question": "In the Observer pattern, what happens when the observed object changes state?", "answer": "All dependent objects are notified and updated automatically", "type": "Multiple Choice", "options": ["All dependent objects are notified and updated automatically", "The program crashes", "A new object is created", "The object is deleted from memory"]}
{"context": "The Single Responsibility Principle (SRP) states that a class should have only one reason to change, meaning it should have only one responsibility.", "question": "What does the Single Responsibility Principle dictate about a class?", "answer": "It should have only one responsibility", "type": "Multiple Choice", "options": ["It should have only one responsibility", "It should implement multiple interfaces", "It should contain at least five methods", "It must be statically typed"]}
{"context": "Neural networks consist of artificial neurons organized in layers, capable of learning patterns from data. The input layer receives data, hidden layers process it, and the output layer produces results.", "question": "How are artificial neurons organized in neural networks?", "answer": "In layers", "type": "Multiple Choice", "options": ["In layers", "In clusters", "In a hierarchy", "In a circular formation"]}
{"context": "Supervised Learning is where models learn from labeled training data to predict outputs for unseen data. Key components include features, labels, and a loss function to measure prediction errors.", "question": "What type of data do supervised learning models learn from?", "answer": "Labeled training data", "type": "Multiple Choice", "options": ["Labeled training data", "Unlabeled data", "Synthetic data", "Real-time data"]}
{"context": "A hash table is a data structure that implements an associative array abstract data type, a structure that can map keys to values. A hash table uses a hash function to compute an index into an array of buckets or slots.", "question": "What function does a hash table use to compute an index?", "answer": "A hash function", "type": "Multiple Choice", "options": ["A hash function", "A sorting algorithm", "A binary search", "A linked list"]}
{"context": "RESTful APIs use HTTP requests to perform CRUD (Create, Read, Update, Delete) operations. They are stateless, meaning each request from client to server must contain all information needed to understand and process the request.", "question": "What does it mean for RESTful APIs to be stateless?", "answer": "Each request must contain all information needed to understand and process the request", "type": "Multiple Choice", "options": ["Each request must contain all information needed to understand and process the request", "The server does not store any data", "APIs cannot be modified after creation", "The system must use JSON format"]}
{"context": "Containerization, like Docker, packages an application with its dependencies, libraries, and other binaries, and with configurations needed to run it. This eliminates the 'it works on my machine' problem.", "question": "What problem does containerization help eliminate?", "answer": "The 'it works on my machine' problem", "type": "Multiple Choice", "options": ["The 'it works on my machine' problem", "The need for operating systems", "Memory leaks", "Network security issues"]}
{"context": "The Open/Closed Principle states that software entities should be open for extension but closed for modification. This means you should be able to add new functionality without changing existing code.", "question": "According to the Open/Closed Principle, what should software entities be?", "answer": "Open for extension but closed for modification", "type": "Multiple Choice", "options": ["Open for extension but closed for modification", "Open source and freely available", "Closed for extension but open for modification", "Open to everyone but closed to competitors"]}
{"context": "A depth-first search (DFS) is an algorithm for traversing or searching tree or graph data structures. It starts at the root and explores as far as possible along each branch before backtracking.", "question": "How does a depth-first search algorithm explore a tree?", "answer": "It explores as far as possible along each branch before backtracking", "type": "Multiple Choice", "options": ["It explores as far as possible along each branch before backtracking", "It visits all nodes at the same level before moving to the next level", "It randomly selects nodes to explore", "It always explores the shortest path first"]}